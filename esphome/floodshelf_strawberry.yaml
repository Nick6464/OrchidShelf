esphome:
  name: "esphome-web-456420"
  friendly_name: Strawberry Flood Irrigation Shelf
  min_version: 2025.8.0
  name_add_mac_suffix: false
  includes:
    - flood_helpers_single_bin.h

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Load VL6180X custom component
external_components:
  - source: github://Nick6464/vl6180x-esphome
    components: [ vl6180x ]
    refresh: 0s  # Force refresh from GitHub

# I2C Bus for VL6180X sensor
# Using GPIO26/27 for I2C
i2c:
  - id: bus_bin_1
    sda: GPIO26
    scl: GPIO27
    scan: true
    frequency: 100kHz 

# Global variables for tracking bin state and last cycle time
globals:
  - id: pump_1_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_1_last_cycle
    type: int
    initial_value: '0'
  - id: bin_1_next_cycle
    type: int
    initial_value: '0'
  - id: bin_1_last_run_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_1_schedule_mode
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_1_daily_times_var
    type: std::string
    restore_value: true
    initial_value: '"10"'
  - id: bin_1_interval_time
    type: int
    restore_value: true
    initial_value: '10'
  - id: bin_1_sensor_zero_offset
    type: float
    restore_value: true
    initial_value: '0.0'

# Define outputs for HW-095 board
output:
  # HW-095 Board - Motor A (Pump 1)
  - platform: ledc
    pin: GPIO32
    id: motor_a_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO33
    id: motor_a_in1
  - platform: gpio
    pin: GPIO25
    id: motor_a_in2

# VL6180X ToF Sensor
sensor:
  - platform: vl6180x
    name: "Bin 1 Water Distance"
    id: bin_1_distance
    update_interval: 1s
    samples: 5
    delta_threshold: 5.0
    i2c_id: bus_bin_1

  - platform: template
    name: "Water Depth"
    id: bin_1_water_depth
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    icon: mdi:water-plus
    update_interval: 1s
    lambda: |-
      float current_distance = id(bin_1_distance).state;
      float zero_offset = id(bin_1_sensor_zero_offset);
      if (zero_offset == 0.0) {
        return 0.0;
      }
      // Depth = distance from zeroed position (positive when water rises closer to sensor)
      return zero_offset - current_distance;

  - platform: template
    name: "Sensor Zero Offset"
    id: bin_1_zero_offset_display
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    icon: mdi:crosshairs-gps
    update_interval: 60s
    lambda: |-
      return id(bin_1_sensor_zero_offset);

# Create switch entity for pump
switch:
  - platform: template
    name: "Peristaltic Pump"
    id: pump_1
    optimistic: true
    turn_on_action:
      - lambda: |-
          bool reverse = id(pump_1_reverse).state;
          std::string speed = reverse ? id(pump_1_drain_speed).state : id(pump_1_fill_speed).state;
          id(motor_a_speed)->set_level(speed_to_level(speed));
          id(motor_a_in1)->turn_off();
          id(motor_a_in2)->turn_off();
          (reverse ? id(motor_a_in2) : id(motor_a_in1))->turn_on();
    turn_off_action:
      - lambda: |-
          id(motor_a_in1)->turn_off();
          id(motor_a_in2)->turn_off();
          id(motor_a_speed)->set_level(0.0);

  - platform: template
    name: "Pump Reverse"
    id: pump_1_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_drain_speed).state;
                  return speed_to_level(speed);
            - output.turn_off: motor_a_in1
            - output.turn_on: motor_a_in2
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_fill_speed).state;
                  return speed_to_level(speed);
            - output.turn_on: motor_a_in1
            - output.turn_off: motor_a_in2

  - platform: template
    name: "Bin Enable"
    id: bin_1_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check

# Fill and drain speed selectors
select:
  - platform: template
    name: "Pump Fill Speed"
    id: pump_1_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump Drain Speed"
    id: pump_1_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Schedule Mode"
    id: bin_1_schedule_mode_select
    options:
      - "Interval Days"
      - "Daily Times"
    icon: mdi:calendar-clock
    lambda: |-
      return id(bin_1_schedule_mode) == 1 ? std::string("Daily Times") : std::string("Interval Days");
    set_action:
      then:
        - lambda: |-
            std::string mode = x;
            id(bin_1_schedule_mode) = (mode == "Daily Times") ? 1 : 0;

# Time component with scheduling
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: 0
        minutes: 0
        then:
          - lambda: |-
              auto now = id(homeassistant_time).now();
              int current_hour = now.hour;
              int current_day = now.day_of_year;
              auto current_time = now.timestamp;
              
              if (id(bin_1_enable).state) {
                bool should_run = false;
                
                if (id(bin_1_schedule_mode) == 0) {
                  // Interval Days mode
                  int last_run_day = id(bin_1_last_run_day);
                  int days_since = 0;
                  if (last_run_day > 0) {
                    days_since = (current_day - last_run_day + 365) % 365;
                  }
                  
                  float interval_days = id(pump_1_cycle_interval).state;
                  int interval_time = id(bin_1_interval_time);
                  
                  if (current_hour == interval_time && days_since >= (int)interval_days) {
                    should_run = true;
                    id(bin_1_last_run_day) = current_day;
                  }
                } else {
                  // Daily Times mode
                  std::string daily_times = id(ha_bin_1_daily_times).state;
                  std::stringstream ss(daily_times);
                  std::string time_str;
                  while (std::getline(ss, time_str, ',')) {
                    time_str.erase(0, time_str.find_first_not_of(" \t"));
                    time_str.erase(time_str.find_last_not_of(" \t") + 1);
                    if (!time_str.empty()) {
                      int time_hour = std::stoi(time_str);
                      if (current_hour == time_hour) {
                        should_run = true;
                        break;
                      }
                    }
                  }
                }
                
                if (should_run && id(pump_1_state) == "Idle") {
                  id(pump_1_last_cycle) = current_time;
                  id(bin_1_next_cycle) = current_time;
                  id(pump_1_flood_cycle)->execute();
                }
              }

# Sensors and status
text_sensor:
  - platform: homeassistant
    id: ha_bin_1_daily_times
    entity_id: input_text.floodshelf_strawberry_bin_1_daily_times
    internal: true

  - platform: template
    name: "Bin Status"
    id: pump_1_status
    lambda: |-
      return {id(pump_1_state)};
    update_interval: 1s

  - platform: template
    name: "Next Cycle Countdown Text"
    id: pump_1_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) return {"Unknown"};
      
      int schedule_mode = id(bin_1_schedule_mode);
      
      if (schedule_mode == 0) {
        // Interval Days mode
        int last_run_day = id(bin_1_last_run_day);
        int current_day = now.day_of_year;
        int days_since = 0;
        if (last_run_day > 0) {
          days_since = (current_day - last_run_day + 365) % 365;
        }
        
        float interval_days = id(pump_1_cycle_interval).state;
        int days_until = (int)interval_days - days_since;
        
        if (days_until < 0) days_until = 0;
        
        return {std::to_string(days_until) + " days"};
      } else {
        // Daily Times mode
        return {"Daily Schedule"};
      }

# Depth and timing settings
number:
  - platform: template
    name: "Target Depth mm"
    id: bin_1_target_depth
    min_value: 5
    max_value: 150
    step: 5
    mode: box
    initial_value: 50
    optimistic: true
    icon: mdi:water-plus

  - platform: template
    name: "Empty Distance mm"
    id: bin_1_empty_distance
    min_value: 50
    max_value: 300
    step: 5
    mode: box
    initial_value: 200
    optimistic: true
    icon: mdi:ruler

  - platform: template
    name: "Max Fill Time Minutes"
    id: bin_1_max_fill_time
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 15
    optimistic: true
    icon: mdi:timer-outline

  - platform: template
    name: "Soak Duration Minutes"
    id: pump_1_soak_duration
    min_value: 1
    max_value: 480
    step: 1
    mode: box
    initial_value: 60
    optimistic: true
    icon: mdi:timer-sand

  - platform: template
    name: "Cycle Interval Days"
    id: pump_1_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Interval Time Hour"
    id: pump_1_interval_time
    min_value: 0
    max_value: 23
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

# Manual cycle button
button:
  - platform: template
    name: "Start Cycle"
    id: start_pump_1_cycle
    on_press:
      - lambda: |-
          auto current_time = id(homeassistant_time).now().timestamp;
          id(pump_1_last_cycle) = current_time;
          id(bin_1_next_cycle) = current_time;
      - script.execute: pump_1_flood_cycle

  - platform: template
    name: "Zero Sensor"
    id: zero_bin_1_sensor
    icon: mdi:crosshairs
    on_press:
      - lambda: |-
          float current_reading = id(bin_1_distance).state;
          id(bin_1_sensor_zero_offset) = current_reading;
          ESP_LOGI("calibration", "Sensor zeroed at %.2f mm", current_reading);

# Depth-based flood cycle script
script:
  - id: pump_1_flood_cycle
    mode: single
    then:
      - globals.set:
          id: pump_1_state
          value: '"Filling"'
      - logger.log: "Bin 1: Starting depth-based fill cycle"
      - switch.turn_on: pump_1_reverse
      - switch.turn_on: pump_1
      # Wait for target depth or max time
      - wait_until:
          timeout: !lambda "return (int)(id(bin_1_max_fill_time).state * 60 * 1000);"
          condition:
            lambda: |-
              float target = id(bin_1_target_depth).state;
              float current = calculate_water_depth(1, id(bin_1_distance).state);
              return current >= target;
      - switch.turn_off: pump_1
      - globals.set:
          id: pump_1_state
          value: '"Soaking"'
      - logger.log: "Bin 1: Target depth reached, soaking"
      - delay: !lambda "return (int)(id(pump_1_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_1_state
          value: '"Draining"'
      - logger.log: "Bin 1: Starting drain"
      - switch.turn_off: pump_1_reverse
      - switch.turn_on: pump_1
      # Drain until water is gone
      - wait_until:
          timeout: 20min
          condition:
            lambda: |-
              float empty_distance = id(bin_1_empty_distance).state;
              float current_distance = id(bin_1_distance).state;
              return current_distance >= (empty_distance - 5);
      - switch.turn_off: pump_1
      - switch.turn_off: pump_1_reverse
      - globals.set:
          id: pump_1_state
          value: '"Idle"'
      - logger.log: "Bin 1: Cycle complete"
