esphome:
  name: "floodshelf"
  friendly_name: Flood Irrigation Shelf
  min_version: 2025.8.0
  name_add_mac_suffix: false
  includes:
    - flood_helpers.h

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Global variables for tracking bin states and last cycle times
globals:
  - id: pump_1_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_2_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_3_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_4_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_1_last_cycle
    type: int
    initial_value: '0'
  - id: pump_2_last_cycle
    type: int
    initial_value: '0'
  - id: pump_3_last_cycle
    type: int
    initial_value: '0'
  - id: pump_4_last_cycle
    type: int
    initial_value: '0'
  # Sequential pump queue management
  - id: current_pump_sequence
    type: int
    initial_value: '1'  # Start with pump 1
  - id: queue_bin_1
    type: int
    initial_value: '1'  # Position in queue (1-4, 0 = not in queue)
  - id: queue_bin_2
    type: int
    initial_value: '2'
  - id: queue_bin_3
    type: int
    initial_value: '3'
  - id: queue_bin_4
    type: int
    initial_value: '4'
  - id: next_bin_to_run
    type: int
    initial_value: '1'  # Tracks which bin is next in the queue
  # Queue system for pending cycles
  - id: queue_pending_1
    type: bool
    initial_value: 'false'
  - id: queue_pending_2
    type: bool
    initial_value: 'false'
  - id: queue_pending_3
    type: bool
    initial_value: 'false'
  - id: queue_pending_4
    type: bool
    initial_value: 'false'
  # Next cycle timestamps for each bin
  - id: bin_1_next_cycle
    type: int
    initial_value: '0'
  - id: bin_2_next_cycle
    type: int
    initial_value: '0'
  - id: bin_3_next_cycle
    type: int
    initial_value: '0'
  - id: bin_4_next_cycle
    type: int
    initial_value: '0'
  # Schedule tracking variables for each bin
  - id: bin_1_last_run_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_2_last_run_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_3_last_run_day
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_4_last_run_day
    type: int
    restore_value: true
    initial_value: '0'
  # Schedule mode for each bin (0 = interval days, 1 = daily times)
  - id: bin_1_schedule_mode
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_2_schedule_mode
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_3_schedule_mode
    type: int
    restore_value: true
    initial_value: '0'
  - id: bin_4_schedule_mode
    type: int
    restore_value: true
    initial_value: '0'
  # Daily times for each bin (stored as comma-separated hour values, e.g., "8,14,18" for 8AM, 2PM, 6PM)
  - id: bin_1_daily_times_var
    type: std::string
    restore_value: true
    initial_value: '"10"'
  - id: bin_2_daily_times_var
    type: std::string
    restore_value: true
    initial_value: '"10"'
  - id: bin_3_daily_times_var
    type: std::string
    restore_value: true
    initial_value: '"10"'
  - id: bin_4_daily_times_var
    type: std::string
    restore_value: true
    initial_value: '"10"'
  # Interval time for each bin (hour of day for interval-based scheduling)
  - id: bin_1_interval_time
    type: int
    restore_value: true
    initial_value: '10'
  - id: bin_2_interval_time
    type: int
    restore_value: true
    initial_value: '10'
  - id: bin_3_interval_time
    type: int
    restore_value: true
    initial_value: '10'
  - id: bin_4_interval_time
    type: int
    restore_value: true
    initial_value: '10'

# Define outputs for both HW-095 boards
output:
  # HW-095 Board #1 - Motor A (Pump 1)
  - platform: ledc
    pin: GPIO23
    id: motor_a_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO22
    id: motor_a_in1
  - platform: gpio
    pin: GPIO21
    id: motor_a_in2

  # HW-095 Board #1 - Motor B (Pump 2)
  - platform: ledc
    pin: GPIO19
    id: motor_b_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO18
    id: motor_b_in3
  - platform: gpio
    pin: GPIO17
    id: motor_b_in4

  # HW-095 Board #2 - Motor A (Pump 3)
  - platform: ledc
    pin: GPIO25
    id: motor_c_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO26
    id: motor_c_in1
  - platform: gpio
    pin: GPIO27
    id: motor_c_in2

  # HW-095 Board #2 - Motor B (Pump 4)
  - platform: ledc
    pin: GPIO32
    id: motor_d_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO33
    id: motor_d_in3
  - platform: gpio
    pin: GPIO16
    id: motor_d_in4

# Create simple switch entities for all 4 pumps (65% fixed speed)
switch:
  - platform: template
    name: "Peristaltic Pump 1"
    id: pump_1
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_a_speed
          level: !lambda |-
            std::string speed = id(pump_1_reverse).state ? id(pump_1_drain_speed).state : id(pump_1_fill_speed).state;
            return speed_to_level(speed);
      - if:
          condition:
            switch.is_on: pump_1_reverse
          then:
            - output.turn_off: motor_a_in1
            - output.turn_on: motor_a_in2
          else:
            - output.turn_on: motor_a_in1
            - output.turn_off: motor_a_in2
    turn_off_action:
      - output.turn_off: motor_a_in1
      - output.turn_off: motor_a_in2
      - output.set_level:
          id: motor_a_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 2"
    id: pump_2
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_b_speed
          level: !lambda |-
            std::string speed = id(pump_2_reverse).state ? id(pump_2_drain_speed).state : id(pump_2_fill_speed).state;
            return speed_to_level(speed);
      - if:
          condition:
            switch.is_on: pump_2_reverse
          then:
            - output.turn_off: motor_b_in3
            - output.turn_on: motor_b_in4
          else:
            - output.turn_on: motor_b_in3
            - output.turn_off: motor_b_in4
    turn_off_action:
      - output.turn_off: motor_b_in3
      - output.turn_off: motor_b_in4
      - output.set_level:
          id: motor_b_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 3"
    id: pump_3
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_c_speed
          level: !lambda |-
            std::string speed = id(pump_3_reverse).state ? id(pump_3_drain_speed).state : id(pump_3_fill_speed).state;
            return speed_to_level(speed);
      - if:
          condition:
            switch.is_on: pump_3_reverse
          then:
            - output.turn_off: motor_c_in1
            - output.turn_on: motor_c_in2
          else:
            - output.turn_on: motor_c_in1
            - output.turn_off: motor_c_in2
    turn_off_action:
      - output.turn_off: motor_c_in1
      - output.turn_off: motor_c_in2
      - output.set_level:
          id: motor_c_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 4"
    id: pump_4
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_d_speed
          level: !lambda |-
            std::string speed = id(pump_4_reverse).state ? id(pump_4_drain_speed).state : id(pump_4_fill_speed).state;
            return speed_to_level(speed);
      - if:
          condition:
            switch.is_on: pump_4_reverse
          then:
            - output.turn_off: motor_d_in3
            - output.turn_on: motor_d_in4
          else:
            - output.turn_on: motor_d_in3
            - output.turn_off: motor_d_in4
    turn_off_action:
      - output.turn_off: motor_d_in3
      - output.turn_off: motor_d_in4
      - output.set_level:
          id: motor_d_speed
          level: 0.0

  # Direction control switches for all pumps
  - platform: template
    name: "Pump 1 Reverse"
    id: pump_1_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_drain_speed).state;
                  return speed_to_level(speed);
            - output.turn_off: motor_a_in1
            - output.turn_on: motor_a_in2
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_fill_speed).state;
                  return speed_to_level(speed);
            - output.turn_on: motor_a_in1
            - output.turn_off: motor_a_in2

  - platform: template
    name: "Pump 2 Reverse"
    id: pump_2_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_2
          then:
            - output.set_level:
                id: motor_b_speed
                level: !lambda |-
                  std::string speed = id(pump_2_drain_speed).state;
                  return speed_to_level(speed);
            - output.turn_off: motor_b_in3
            - output.turn_on: motor_b_in4
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_2
          then:
            - output.set_level:
                id: motor_b_speed
                level: !lambda |-
                  std::string speed = id(pump_2_fill_speed).state;
                  return speed_to_level(speed);
            - output.turn_on: motor_b_in3
            - output.turn_off: motor_b_in4

  - platform: template
    name: "Pump 3 Reverse"
    id: pump_3_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_3
          then:
            - output.set_level:
                id: motor_c_speed
                level: !lambda |-
                  std::string speed = id(pump_3_drain_speed).state;
                  return speed_to_level(speed);
            - output.turn_off: motor_c_in1
            - output.turn_on: motor_c_in2
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_3
          then:
            - output.set_level:
                id: motor_c_speed
                level: !lambda |-
                  std::string speed = id(pump_3_fill_speed).state;
                  return speed_to_level(speed);
            - output.turn_on: motor_c_in1
            - output.turn_off: motor_c_in2

  - platform: template
    name: "Pump 4 Reverse"
    id: pump_4_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_4
          then:
            - output.set_level:
                id: motor_d_speed
                level: !lambda |-
                  std::string speed = id(pump_4_drain_speed).state;
                  return speed_to_level(speed);
            - output.turn_off: motor_d_in3
            - output.turn_on: motor_d_in4
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_4
          then:
            - output.set_level:
                id: motor_d_speed
                level: !lambda |-
                  std::string speed = id(pump_4_fill_speed).state;
                  return speed_to_level(speed);
            - output.turn_on: motor_d_in3
            - output.turn_off: motor_d_in4

  # Master switches
  - platform: template
    name: "All Pumps On/Off"
    id: all_pumps_master
    optimistic: true
    turn_on_action:
      - switch.turn_on: pump_1
      - switch.turn_on: pump_2
      - switch.turn_on: pump_3
      - switch.turn_on: pump_4
    turn_off_action:
      - switch.turn_off: pump_1
      - switch.turn_off: pump_2
      - switch.turn_off: pump_3
      - switch.turn_off: pump_4

  # Bin enable/disable switches for sequential cycling (also controls auto scheduling)
  - platform: template
    name: "Bin 1 Enable"
    id: bin_1_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 2 Enable"
    id: bin_2_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 3 Enable"
    id: bin_3_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 4 Enable"
    id: bin_4_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check

# Fill and drain speed selectors for each pump
select:
  - platform: template
    name: "Pump 1 Fill Speed"
    id: pump_1_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 1 Drain Speed"
    id: pump_1_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 2 Fill Speed"
    id: pump_2_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 2 Drain Speed"
    id: pump_2_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 3 Fill Speed"
    id: pump_3_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 3 Drain Speed"
    id: pump_3_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 4 Fill Speed"
    id: pump_4_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 4 Drain Speed"
    id: pump_4_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  # Schedule mode selectors for each bin
  - platform: template
    name: "Bin 1 Schedule Mode"
    id: bin_1_schedule_mode_select
    options:
      - "Interval Days"
      - "Daily Times"
    icon: mdi:calendar-clock
    lambda: |-
      return id(bin_1_schedule_mode) == 1 ? std::string("Daily Times") : std::string("Interval Days");
    set_action:
      then:
        - lambda: |-
            std::string mode = x;
            id(bin_1_schedule_mode) = (mode == "Daily Times") ? 1 : 0;

  - platform: template
    name: "Bin 2 Schedule Mode"
    id: bin_2_schedule_mode_select
    options:
      - "Interval Days"
      - "Daily Times"
    icon: mdi:calendar-clock
    lambda: |-
      return id(bin_2_schedule_mode) == 1 ? std::string("Daily Times") : std::string("Interval Days");
    set_action:
      then:
        - lambda: |-
            std::string mode = x;
            id(bin_2_schedule_mode) = (mode == "Daily Times") ? 1 : 0;

  - platform: template
    name: "Bin 3 Schedule Mode"
    id: bin_3_schedule_mode_select
    options:
      - "Interval Days"
      - "Daily Times"
    icon: mdi:calendar-clock
    lambda: |-
      return id(bin_3_schedule_mode) == 1 ? std::string("Daily Times") : std::string("Interval Days");
    set_action:
      then:
        - lambda: |-
            std::string mode = x;
            id(bin_3_schedule_mode) = (mode == "Daily Times") ? 1 : 0;

  - platform: template
    name: "Bin 4 Schedule Mode"
    id: bin_4_schedule_mode_select
    options:
      - "Interval Days"
      - "Daily Times"
    icon: mdi:calendar-clock
    lambda: |-
      return id(bin_4_schedule_mode) == 1 ? std::string("Daily Times") : std::string("Interval Days");
    set_action:
      then:
        - lambda: |-
            std::string mode = x;
            id(bin_4_schedule_mode) = (mode == "Daily Times") ? 1 : 0;



# Time component with on_time scheduling
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: 0
        minutes: 0
        then:
          - lambda: |-
              auto now = id(homeassistant_time).now();
              int current_hour = now.hour;
              int current_day = now.day_of_year;
              auto current_time = now.timestamp;
              
              // Check each bin individually for schedule matches
              for (int bin = 1; bin <= 4; bin++) {
                if (get_bin_enable(bin)) {
                  bool should_run = false;
                  
                  // Get this bin's schedule mode
                  int schedule_mode = 0;
                  switch(bin) {
                    case 1: schedule_mode = id(bin_1_schedule_mode); break;
                    case 2: schedule_mode = id(bin_2_schedule_mode); break;
                    case 3: schedule_mode = id(bin_3_schedule_mode); break;
                    case 4: schedule_mode = id(bin_4_schedule_mode); break;
                  }
                  
                  if (schedule_mode == 0) {
                    // Interval Days mode
                    // Get this bin's last run day
                    int last_run_day = 0;
                    switch(bin) {
                      case 1: last_run_day = id(bin_1_last_run_day); break;
                      case 2: last_run_day = id(bin_2_last_run_day); break;
                      case 3: last_run_day = id(bin_3_last_run_day); break;
                      case 4: last_run_day = id(bin_4_last_run_day); break;
                    }
                    
                    // Calculate days since last run
                    int days_since = 0;
                    if (last_run_day > 0) {
                      days_since = (current_day - last_run_day + 365) % 365;
                    } else {
                      // If never run before, treat as if it ran 0 days ago
                      days_since = 0;
                    }
                    
                    // Get this bin's cycle interval
                    float interval_days = get_cycle_interval(bin);
                    
                    // Get this bin's interval time
                    int interval_time = 10; // default
                    switch(bin) {
                      case 1: interval_time = id(bin_1_interval_time); break;
                      case 2: interval_time = id(bin_2_interval_time); break;
                      case 3: interval_time = id(bin_3_interval_time); break;
                      case 4: interval_time = id(bin_4_interval_time); break;
                    }
                    
                    // Check if it's time for this bin to run (every N days at specified time)
                    if (current_hour == interval_time && days_since >= (int)interval_days) {
                      should_run = true;
                    }
                  } else {
                    // Daily Times mode
                    std::string daily_times = "";
                    switch(bin) {
                      case 1: daily_times = id(ha_bin_1_daily_times).state; break;
                      case 2: daily_times = id(ha_bin_2_daily_times).state; break;
                      case 3: daily_times = id(ha_bin_3_daily_times).state; break;
                      case 4: daily_times = id(ha_bin_4_daily_times).state; break;
                    }
                    
                    // Parse comma-separated times and check if current hour matches
                    std::stringstream ss(daily_times);
                    std::string time_str;
                    while (std::getline(ss, time_str, ',')) {
                      // Trim whitespace and skip empty strings
                      time_str.erase(0, time_str.find_first_not_of(" \t"));
                      time_str.erase(time_str.find_last_not_of(" \t") + 1);
                      if (!time_str.empty()) {
                        int time_hour = std::stoi(time_str);
                        if (current_hour == time_hour) {
                          should_run = true;
                          break;
                        }
                      }
                    }
                  }
                  
                  if (should_run) {
                    set_queue_pending(bin, true);
                    set_next_cycle_time(bin, current_time);
                    
                    // Update last run day for this bin (only for interval mode)
                    int schedule_mode = 0;
                    switch(bin) {
                      case 1: schedule_mode = id(bin_1_schedule_mode); break;
                      case 2: schedule_mode = id(bin_2_schedule_mode); break;
                      case 3: schedule_mode = id(bin_3_schedule_mode); break;
                      case 4: schedule_mode = id(bin_4_schedule_mode); break;
                    }
                    
                    if (schedule_mode == 0) {
                      switch(bin) {
                        case 1: id(bin_1_last_run_day) = current_day; break;
                        case 2: id(bin_2_last_run_day) = current_day; break;
                        case 3: id(bin_3_last_run_day) = current_day; break;
                        case 4: id(bin_4_last_run_day) = current_day; break;
                      }
                    }
                  }
                }
              }
              
              // Process queue - only if all pumps are idle
              if (are_all_pumps_idle()) {
                // Check queue in order and run next pending cycle
                for (int bin = 1; bin <= 4; bin++) {
                  if (get_queue_pending(bin)) {
                    set_queue_pending(bin, false);
                    set_last_cycle(bin, now.timestamp);
                    execute_flood_cycle(bin);
                    break; // Only run one cycle at a time
                  }
                }
              }
    


# Sensors for countdown and status
sensor:
  # Debug time sensor to check timezone
  - platform: template
    name: "Debug Current Time"
    id: debug_time_sensor
    icon: mdi:clock
    update_interval: 30s
    lambda: |-
      auto now = id(homeassistant_time).now();
      return now.timestamp;
    unit_of_measurement: "timestamp"
    
  # Queue count sensor  
  - platform: template
    name: "Pending Queue Count"
    id: pending_count_sensor
    icon: mdi:format-list-numbered
    lambda: |-
      int count = 0;
      for (int bin = 1; bin <= 4; bin++) {
        if (get_queue_pending(bin)) count++;
      }
      return count;
    unit_of_measurement: "cycles"
  - platform: template
    name: "Bin 1 Next Cycle Countdown"
    id: pump_1_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return calculate_countdown_hours(1);
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 2 Next Cycle Countdown"
    id: pump_2_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return calculate_countdown_hours(2);
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 3 Next Cycle Countdown"
    id: pump_3_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return calculate_countdown_hours(3);
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 4 Next Cycle Countdown"
    id: pump_4_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return calculate_countdown_hours(4);
    unit_of_measurement: "hours"

# Text sensors for bin status and cron schedules
text_sensor:
  # Home Assistant input_text sensors for daily times
  - platform: homeassistant
    id: ha_bin_1_daily_times
    entity_id: input_text.floodshelf_bin_1_daily_times
    internal: true
  - platform: homeassistant
    id: ha_bin_2_daily_times
    entity_id: input_text.floodshelf_bin_2_daily_times
    internal: true
  - platform: homeassistant
    id: ha_bin_3_daily_times
    entity_id: input_text.floodshelf_bin_3_daily_times
    internal: true
  - platform: homeassistant
    id: ha_bin_4_daily_times
    entity_id: input_text.floodshelf_bin_4_daily_times
    internal: true

  # Debug time sensor to check timezone
  - platform: template
    name: "Debug Time Display"
    id: debug_time_display
    icon: mdi:clock
    update_interval: 30s
    lambda: |-
      auto now = id(homeassistant_time).now();
      std::string time_str = std::to_string(now.hour) + ":" + 
                           (now.minute < 10 ? "0" : "") + std::to_string(now.minute) + ":" +
                           (now.second < 10 ? "0" : "") + std::to_string(now.second);
      return {time_str};

      
  # Queue status sensor (string values)
  - platform: template
    name: "Queue Status"
    id: queue_status_sensor
    icon: mdi:playlist-play
    lambda: |-
      std::string status = "";
      int count = 0;
      for (int bin = 1; bin <= 4; bin++) {
        if (get_queue_pending(bin)) { 
          status += "Bin " + std::to_string(bin) + ", "; 
          count++; 
        }
      }
      
      if (count == 0) return {"Empty"};
      if (status.length() > 2) status = status.substr(0, status.length() - 2);
      return {status};
    update_interval: 10s

  - platform: template
    name: "Bin 1 Status"
    id: pump_1_status
    lambda: |-
      return get_pump_state(1);
    update_interval: 1s

  # Human-readable countdown sensors
  - platform: template
    name: "Bin 1 Next Cycle Countdown Text"
    id: pump_1_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return {calculate_countdown_text(1)};

  - platform: template
    name: "Bin 2 Status"
    id: pump_2_status
    lambda: |-
      return get_pump_state(2);
    update_interval: 1s

  - platform: template
    name: "Bin 2 Next Cycle Countdown Text"
    id: pump_2_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return {calculate_countdown_text(2)};

  - platform: template
    name: "Bin 3 Status"
    id: pump_3_status
    lambda: |-
      return get_pump_state(3);
    update_interval: 1s

  - platform: template
    name: "Bin 3 Next Cycle Countdown Text"
    id: pump_3_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return {calculate_countdown_text(3)};

  - platform: template
    name: "Bin 4 Status"
    id: pump_4_status
    lambda: |-
      return get_pump_state(4);
    update_interval: 1s

  - platform: template
    name: "Bin 4 Next Cycle Countdown Text"
    id: pump_4_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      return {calculate_countdown_text(4)};

  # Daily times display sensors
  - platform: template
    name: "Bin 1 Daily Times"
    id: bin_1_daily_times
    icon: mdi:clock-outline
    lambda: |-
      return id(ha_bin_1_daily_times).state;

  - platform: template
    name: "Bin 2 Daily Times"
    id: bin_2_daily_times
    icon: mdi:clock-outline
    lambda: |-
      return id(ha_bin_2_daily_times).state;

  - platform: template
    name: "Bin 3 Daily Times"
    id: bin_3_daily_times
    icon: mdi:clock-outline
    lambda: |-
      return id(ha_bin_3_daily_times).state;

  - platform: template
    name: "Bin 4 Daily Times"
    id: bin_4_daily_times
    icon: mdi:clock-outline
    lambda: |-
      return id(ha_bin_4_daily_times).state;

# Pump timing settings only (speed is fixed at 65%)
number:
  # Bin 1 Timing Settings
  - platform: template
    name: "Bin 1 Fill Duration Minutes"
    id: pump_1_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 1 Soak Duration Minutes"
    id: pump_1_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 1 Drain Duration Minutes"
    id: pump_1_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 1 Cycle Interval Days"
    id: pump_1_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  - platform: template
    name: "Bin 1 Interval Time Hour"
    id: pump_1_interval_time
    min_value: 0
    max_value: 23
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  # Bin 2 Timing Settings
  - platform: template
    name: "Bin 2 Fill Duration Minutes"
    id: pump_2_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 2 Soak Duration Minutes"
    id: pump_2_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 2 Drain Duration Minutes"
    id: pump_2_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 2 Cycle Interval Days"
    id: pump_2_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  - platform: template
    name: "Bin 2 Interval Time Hour"
    id: pump_2_interval_time
    min_value: 0
    max_value: 23
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  # Bin 3 Timing Settings
  - platform: template
    name: "Bin 3 Fill Duration Minutes"
    id: pump_3_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 3 Soak Duration Minutes"
    id: pump_3_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 3 Drain Duration Minutes"
    id: pump_3_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 3 Cycle Interval Days"
    id: pump_3_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  - platform: template
    name: "Bin 3 Interval Time Hour"
    id: pump_3_interval_time
    min_value: 0
    max_value: 23
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  # Bin 4 Timing Settings
  - platform: template
    name: "Bin 4 Fill Duration Minutes"
    id: pump_4_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 4 Soak Duration Minutes"
    id: pump_4_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 4 Drain Duration Minutes"
    id: pump_4_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 4 Cycle Interval Days"
    id: pump_4_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  - platform: template
    name: "Bin 4 Interval Time Hour"
    id: pump_4_interval_time
    min_value: 0
    max_value: 23
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

# Manual cycle buttons
button:
  - platform: template
    name: "Start Bin 1 Cycle"
    id: start_pump_1_cycle
    on_press:
      - lambda: |-
          auto current_time = id(homeassistant_time).now().timestamp;
          set_last_cycle(1, current_time);
          set_next_cycle_time(1, current_time);
          set_queue_pending(1, false);
      - script.execute: pump_1_flood_cycle

  - platform: template
    name: "Start Bin 2 Cycle"
    id: start_pump_2_cycle
    on_press:
      - lambda: |-
          auto current_time = id(homeassistant_time).now().timestamp;
          set_last_cycle(2, current_time);
          set_next_cycle_time(2, current_time);
          set_queue_pending(2, false);
      - script.execute: pump_2_flood_cycle

  - platform: template
    name: "Start Bin 3 Cycle"
    id: start_pump_3_cycle
    on_press:
      - lambda: |-
          auto current_time = id(homeassistant_time).now().timestamp;
          set_last_cycle(3, current_time);
          set_next_cycle_time(3, current_time);
          set_queue_pending(3, false);
      - script.execute: pump_3_flood_cycle

  - platform: template
    name: "Start Bin 4 Cycle"
    id: start_pump_4_cycle
    on_press:
      - lambda: |-
          auto current_time = id(homeassistant_time).now().timestamp;
          set_last_cycle(4, current_time);
          set_next_cycle_time(4, current_time);
          set_queue_pending(4, false);
      - script.execute: pump_4_flood_cycle

  - platform: template
    name: "Clear All Pending Cycles"
    id: clear_queue
    icon: mdi:playlist-remove
    on_press:
      - lambda: |-
          for (int bin = 1; bin <= 4; bin++) {
            set_queue_pending(bin, false);
          }


# Scripts for flood cycles
script:
  - id: pump_1_flood_cycle
    then:
      - globals.set:
          id: pump_1_state
          value: '"Filling"'
      - switch.turn_on: pump_1_reverse
      - switch.turn_on: pump_1
      - delay: !lambda "return (int)(id(pump_1_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_1
      - globals.set:
          id: pump_1_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_1_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_1_state
          value: '"Draining"'
      - switch.turn_off: pump_1_reverse
      - switch.turn_on: pump_1
      - delay: !lambda "return (int)(id(pump_1_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_1
      - switch.turn_off: pump_1_reverse
      - globals.set:
          id: pump_1_state
          value: '"Idle"'

  - id: pump_2_flood_cycle
    then:
      - globals.set:
          id: pump_2_state
          value: '"Filling"'
      - switch.turn_on: pump_2_reverse
      - switch.turn_on: pump_2
      - delay: !lambda "return (int)(id(pump_2_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_2
      - globals.set:
          id: pump_2_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_2_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_2_state
          value: '"Draining"'
      - switch.turn_off: pump_2_reverse
      - switch.turn_on: pump_2
      - delay: !lambda "return (int)(id(pump_2_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_2
      - switch.turn_off: pump_2_reverse
      - globals.set:
          id: pump_2_state
          value: '"Idle"'

  - id: pump_3_flood_cycle
    then:
      - globals.set:
          id: pump_3_state
          value: '"Filling"'
      - switch.turn_on: pump_3_reverse
      - switch.turn_on: pump_3
      - delay: !lambda "return (int)(id(pump_3_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_3
      - globals.set:
          id: pump_3_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_3_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_3_state
          value: '"Draining"'
      - switch.turn_off: pump_3_reverse
      - switch.turn_on: pump_3
      - delay: !lambda "return (int)(id(pump_3_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_3
      - switch.turn_off: pump_3_reverse
      - globals.set:
          id: pump_3_state
          value: '"Idle"'

  - id: pump_4_flood_cycle
    then:
      - globals.set:
          id: pump_4_state
          value: '"Filling"'
      - switch.turn_on: pump_4_reverse
      - switch.turn_on: pump_4
      - delay: !lambda "return (int)(id(pump_4_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_4
      - globals.set:
          id: pump_4_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_4_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_4_state
          value: '"Draining"'
      - switch.turn_off: pump_4_reverse
      - switch.turn_on: pump_4
      - delay: !lambda "return (int)(id(pump_4_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_4
      - switch.turn_off: pump_4_reverse
      - globals.set:
          id: pump_4_state
          value: '"Idle"'

