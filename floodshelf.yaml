esphome:
  name: "floodshelf"
  friendly_name: Flood Irrigation Shelf
  min_version: 2025.8.0
  name_add_mac_suffix: false

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Global variables for tracking bin states and last cycle times
globals:
  - id: pump_1_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_2_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_3_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_4_state
    type: std::string
    initial_value: '"Idle"'
  - id: pump_1_last_cycle
    type: int
    initial_value: '0'
  - id: pump_2_last_cycle
    type: int
    initial_value: '0'
  - id: pump_3_last_cycle
    type: int
    initial_value: '0'
  - id: pump_4_last_cycle
    type: int
    initial_value: '0'
  # Sequential pump queue management
  - id: current_pump_sequence
    type: int
    initial_value: '1'  # Start with pump 1
  - id: queue_bin_1
    type: int
    initial_value: '1'  # Position in queue (1-4, 0 = not in queue)
  - id: queue_bin_2
    type: int
    initial_value: '2'
  - id: queue_bin_3
    type: int
    initial_value: '3'
  - id: queue_bin_4
    type: int
    initial_value: '4'
  - id: next_bin_to_run
    type: int
    initial_value: '1'  # Tracks which bin is next in the queue
  # Queue system for pending cycles
  - id: queue_pending_1
    type: bool
    initial_value: 'false'
  - id: queue_pending_2
    type: bool
    initial_value: 'false'
  - id: queue_pending_3
    type: bool
    initial_value: 'false'
  - id: queue_pending_4
    type: bool
    initial_value: 'false'

# Define outputs for both HW-095 boards
output:
  # HW-095 Board #1 - Motor A (Pump 1)
  - platform: ledc
    pin: GPIO23
    id: motor_a_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO22
    id: motor_a_in1
  - platform: gpio
    pin: GPIO21
    id: motor_a_in2

  # HW-095 Board #1 - Motor B (Pump 2)
  - platform: ledc
    pin: GPIO19
    id: motor_b_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO18
    id: motor_b_in3
  - platform: gpio
    pin: GPIO17
    id: motor_b_in4

  # HW-095 Board #2 - Motor A (Pump 3)
  - platform: ledc
    pin: GPIO25
    id: motor_c_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO26
    id: motor_c_in1
  - platform: gpio
    pin: GPIO27
    id: motor_c_in2

  # HW-095 Board #2 - Motor B (Pump 4)
  - platform: ledc
    pin: GPIO32
    id: motor_d_speed
    frequency: 1000Hz
  - platform: gpio
    pin: GPIO33
    id: motor_d_in3
  - platform: gpio
    pin: GPIO16
    id: motor_d_in4

# Create simple switch entities for all 4 pumps (65% fixed speed)
switch:
  - platform: template
    name: "Peristaltic Pump 1"
    id: pump_1
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_a_speed
          level: !lambda |-
            std::string speed = id(pump_1_reverse).state ? id(pump_1_drain_speed).state : id(pump_1_fill_speed).state;
            if (speed == "55%") return 0.55;
            if (speed == "65%") return 0.65;
            if (speed == "75%") return 0.75;
            if (speed == "85%") return 0.85;
            if (speed == "100%") return 1.0;
            return 0.65; // default
      - if:
          condition:
            switch.is_on: pump_1_reverse
          then:
            - output.turn_off: motor_a_in1
            - output.turn_on: motor_a_in2
          else:
            - output.turn_on: motor_a_in1
            - output.turn_off: motor_a_in2
    turn_off_action:
      - output.turn_off: motor_a_in1
      - output.turn_off: motor_a_in2
      - output.set_level:
          id: motor_a_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 2"
    id: pump_2
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_b_speed
          level: !lambda |-
            std::string speed = id(pump_2_reverse).state ? id(pump_2_drain_speed).state : id(pump_2_fill_speed).state;
            if (speed == "55%") return 0.55;
            if (speed == "65%") return 0.65;
            if (speed == "75%") return 0.75;
            if (speed == "85%") return 0.85;
            if (speed == "100%") return 1.0;
            return 0.65; // default
      - if:
          condition:
            switch.is_on: pump_2_reverse
          then:
            - output.turn_off: motor_b_in3
            - output.turn_on: motor_b_in4
          else:
            - output.turn_on: motor_b_in3
            - output.turn_off: motor_b_in4
    turn_off_action:
      - output.turn_off: motor_b_in3
      - output.turn_off: motor_b_in4
      - output.set_level:
          id: motor_b_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 3"
    id: pump_3
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_c_speed
          level: !lambda |-
            std::string speed = id(pump_3_reverse).state ? id(pump_3_drain_speed).state : id(pump_3_fill_speed).state;
            if (speed == "55%") return 0.55;
            if (speed == "65%") return 0.65;
            if (speed == "75%") return 0.75;
            if (speed == "85%") return 0.85;
            if (speed == "100%") return 1.0;
            return 0.65; // default
      - if:
          condition:
            switch.is_on: pump_3_reverse
          then:
            - output.turn_off: motor_c_in1
            - output.turn_on: motor_c_in2
          else:
            - output.turn_on: motor_c_in1
            - output.turn_off: motor_c_in2
    turn_off_action:
      - output.turn_off: motor_c_in1
      - output.turn_off: motor_c_in2
      - output.set_level:
          id: motor_c_speed
          level: 0.0

  - platform: template
    name: "Peristaltic Pump 4"
    id: pump_4
    optimistic: true
    turn_on_action:
      - output.set_level:
          id: motor_d_speed
          level: !lambda |-
            std::string speed = id(pump_4_reverse).state ? id(pump_4_drain_speed).state : id(pump_4_fill_speed).state;
            if (speed == "55%") return 0.55;
            if (speed == "65%") return 0.65;
            if (speed == "75%") return 0.75;
            if (speed == "85%") return 0.85;
            if (speed == "100%") return 1.0;
            return 0.65; // default
      - if:
          condition:
            switch.is_on: pump_4_reverse
          then:
            - output.turn_off: motor_d_in3
            - output.turn_on: motor_d_in4
          else:
            - output.turn_on: motor_d_in3
            - output.turn_off: motor_d_in4
    turn_off_action:
      - output.turn_off: motor_d_in3
      - output.turn_off: motor_d_in4
      - output.set_level:
          id: motor_d_speed
          level: 0.0

  # Direction control switches for all pumps
  - platform: template
    name: "Pump 1 Reverse"
    id: pump_1_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_drain_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.75;
            - output.turn_off: motor_a_in1
            - output.turn_on: motor_a_in2
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_1
          then:
            - output.set_level:
                id: motor_a_speed
                level: !lambda |-
                  std::string speed = id(pump_1_fill_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.65;
            - output.turn_on: motor_a_in1
            - output.turn_off: motor_a_in2

  - platform: template
    name: "Pump 2 Reverse"
    id: pump_2_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_2
          then:
            - output.set_level:
                id: motor_b_speed
                level: !lambda |-
                  std::string speed = id(pump_2_drain_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.75;
            - output.turn_off: motor_b_in3
            - output.turn_on: motor_b_in4
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_2
          then:
            - output.set_level:
                id: motor_b_speed
                level: !lambda |-
                  std::string speed = id(pump_2_fill_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.65;
            - output.turn_on: motor_b_in3
            - output.turn_off: motor_b_in4

  - platform: template
    name: "Pump 3 Reverse"
    id: pump_3_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_3
          then:
            - output.set_level:
                id: motor_c_speed
                level: !lambda |-
                  std::string speed = id(pump_3_drain_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.75;
            - output.turn_off: motor_c_in1
            - output.turn_on: motor_c_in2
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_3
          then:
            - output.set_level:
                id: motor_c_speed
                level: !lambda |-
                  std::string speed = id(pump_3_fill_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.65;
            - output.turn_on: motor_c_in1
            - output.turn_off: motor_c_in2

  - platform: template
    name: "Pump 4 Reverse"
    id: pump_4_reverse
    optimistic: true
    turn_on_action:
      - if:
          condition:
            switch.is_on: pump_4
          then:
            - output.set_level:
                id: motor_d_speed
                level: !lambda |-
                  std::string speed = id(pump_4_drain_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.75;
            - output.turn_off: motor_d_in3
            - output.turn_on: motor_d_in4
    turn_off_action:
      - if:
          condition:
            switch.is_on: pump_4
          then:
            - output.set_level:
                id: motor_d_speed
                level: !lambda |-
                  std::string speed = id(pump_4_fill_speed).state;
                  if (speed == "55%") return 0.55;
                  if (speed == "65%") return 0.65;
                  if (speed == "75%") return 0.75;
                  if (speed == "85%") return 0.85;
                  if (speed == "100%") return 1.0;
                  return 0.65;
            - output.turn_on: motor_d_in3
            - output.turn_off: motor_d_in4

  # Master switches
  - platform: template
    name: "All Pumps On/Off"
    id: all_pumps_master
    optimistic: true
    turn_on_action:
      - switch.turn_on: pump_1
      - switch.turn_on: pump_2
      - switch.turn_on: pump_3
      - switch.turn_on: pump_4
    turn_off_action:
      - switch.turn_off: pump_1
      - switch.turn_off: pump_2
      - switch.turn_off: pump_3
      - switch.turn_off: pump_4

  # Bin enable/disable switches for sequential cycling (also controls auto scheduling)
  - platform: template
    name: "Bin 1 Enable"
    id: bin_1_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 2 Enable"
    id: bin_2_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 3 Enable"
    id: bin_3_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check
    
  - platform: template
    name: "Bin 4 Enable"
    id: bin_4_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:water-check

# Fill and drain speed selectors for each pump
select:
  - platform: template
    name: "Pump 1 Fill Speed"
    id: pump_1_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 1 Drain Speed"
    id: pump_1_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 2 Fill Speed"
    id: pump_2_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 2 Drain Speed"
    id: pump_2_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 3 Fill Speed"
    id: pump_3_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 3 Drain Speed"
    id: pump_3_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 4 Fill Speed"
    id: pump_4_fill_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "65%"
    icon: mdi:gauge

  - platform: template
    name: "Pump 4 Drain Speed"
    id: pump_4_drain_speed
    optimistic: true
    options:
      - "55%"
      - "65%"
      - "75%"
      - "85%"
      - "100%"
    initial_option: "75%"
    icon: mdi:gauge


# Time component with individual cron schedules and queue processing
time:
  - platform: homeassistant
    id: homeassistant_time
    # Note: Individual bin cron schedules can't be dynamically configured in ESPHome
    # Using interval-based checking as a workaround for configurable schedules
    
# Queue processing and cron checking via interval
interval:
  - interval: 60s  # Check every minute for cron matches and process queue
    then:
      - lambda: |-
          // Check if any bin's cron schedule matches current time and add to queue
          auto now = id(homeassistant_time).now();
          auto current_time = now.timestamp;
          
          // Simple cron parsing for "0 0 HH * * *" format (daily at specific hour)
          // For Bin 1
          if (id(bin_1_enable).state) {
            std::string cron1 = id(bin_1_cron).state;
            if (cron1.length() >= 7) {
              int target_hour = std::stoi(cron1.substr(4, 2));
              if (now.hour == target_hour && now.minute == 0 && 
                  current_time - id(pump_1_last_cycle) >= (int)(id(pump_1_cycle_interval).state * 86400)) {
                id(queue_pending_1) = true;
              }
            }
          }
          
          // For Bin 2
          if (id(bin_2_enable).state) {
            std::string cron2 = id(bin_2_cron).state;
            if (cron2.length() >= 7) {
              int target_hour = std::stoi(cron2.substr(4, 2));
              if (now.hour == target_hour && now.minute == 0 && 
                  current_time - id(pump_2_last_cycle) >= (int)(id(pump_2_cycle_interval).state * 86400)) {
                id(queue_pending_2) = true;
              }
            }
          }
          
          // For Bin 3
          if (id(bin_3_enable).state) {
            std::string cron3 = id(bin_3_cron).state;
            if (cron3.length() >= 7) {
              int target_hour = std::stoi(cron3.substr(4, 2));
              if (now.hour == target_hour && now.minute == 0 && 
                  current_time - id(pump_3_last_cycle) >= (int)(id(pump_3_cycle_interval).state * 86400)) {
                id(queue_pending_3) = true;
              }
            }
          }
          
          // For Bin 4
          if (id(bin_4_enable).state) {
            std::string cron4 = id(bin_4_cron).state;
            if (cron4.length() >= 7) {
              int target_hour = std::stoi(cron4.substr(4, 2));
              if (now.hour == target_hour && now.minute == 0 && 
                  current_time - id(pump_4_last_cycle) >= (int)(id(pump_4_cycle_interval).state * 86400)) {
                id(queue_pending_4) = true;
              }
            }
          }
          
          // Process queue - only if all pumps are idle
          bool all_pumps_idle = (id(pump_1_state) == "Idle" && 
                                id(pump_2_state) == "Idle" && 
                                id(pump_3_state) == "Idle" && 
                                id(pump_4_state) == "Idle");
          
          if (all_pumps_idle) {
            // Check queue in order and run next pending cycle
            if (id(queue_pending_1)) {
              id(queue_pending_1) = false;
              id(pump_1_last_cycle) = current_time;
              id(pump_1_flood_cycle).execute();
            }
            else if (id(queue_pending_2)) {
              id(queue_pending_2) = false;
              id(pump_2_last_cycle) = current_time;
              id(pump_2_flood_cycle).execute();
            }
            else if (id(queue_pending_3)) {
              id(queue_pending_3) = false;
              id(pump_3_last_cycle) = current_time;
              id(pump_3_flood_cycle).execute();
            }
            else if (id(queue_pending_4)) {
              id(queue_pending_4) = false;
              id(pump_4_last_cycle) = current_time;
              id(pump_4_flood_cycle).execute();
            }
          }


# Sensors for countdown and status
sensor:
  # Queue count sensor  
  - platform: template
    name: "Pending Queue Count"
    id: pending_count_sensor
    icon: mdi:format-list-numbered
    lambda: |-
      int count = 0;
      if (id(queue_pending_1)) count++;
      if (id(queue_pending_2)) count++;
      if (id(queue_pending_3)) count++;
      if (id(queue_pending_4)) count++;
      return count;
    unit_of_measurement: "cycles"
  - platform: template
    name: "Bin 1 Next Cycle Countdown"
    id: pump_1_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_1_enable).state) {
        return NAN; // Return NAN when disabled
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron1 = id(bin_1_cron).state;
      
      if (cron1.length() >= 7) {
        int target_hour = std::stoi(cron1.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_1_cycle_interval).state * 86400); // Convert days to seconds
        
        // Calculate next watering time based on last cycle + interval
        time_t next_cycle_time;
        
        // If we haven't had a cycle yet (last_cycle = 0), use current time as baseline
        if (id(pump_1_last_cycle) == 0) {
          // Calculate next watering as interval from now, at the cron hour
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          // Calculate based on actual last cycle + interval
          next_cycle_time = id(pump_1_last_cycle) + cycle_interval_seconds;
          // Adjust next cycle time to match the cron hour
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        // If the calculated time is in the past, skip to next interval
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400; // Add one day
        }
        
        auto time_diff = next_cycle_time - current_time;
        return time_diff / 3600.0; // Convert to hours
      }
      return NAN;
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 2 Next Cycle Countdown"
    id: pump_2_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_2_enable).state) {
        return NAN;
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron2 = id(bin_2_cron).state;
      
      if (cron2.length() >= 7) {
        int target_hour = std::stoi(cron2.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_2_cycle_interval).state * 86400); // Convert days to seconds
        
        // Calculate next watering time based on last cycle + interval
        time_t next_cycle_time;
        
        // If we haven't had a cycle yet (last_cycle = 0), use current time as baseline
        if (id(pump_2_last_cycle) == 0) {
          // Calculate next watering as interval from now, at the cron hour
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          // Calculate based on actual last cycle + interval
          next_cycle_time = id(pump_2_last_cycle) + cycle_interval_seconds;
          // Adjust next cycle time to match the cron hour
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        // If the calculated time is in the past, skip to next interval
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400; // Add one day
        }
        
        auto time_diff = next_cycle_time - current_time;
        return time_diff / 3600.0;
      }
      return NAN;
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 3 Next Cycle Countdown"
    id: pump_3_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_3_enable).state) {
        return NAN;
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron3 = id(bin_3_cron).state;
      
      if (cron3.length() >= 7) {
        int target_hour = std::stoi(cron3.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_3_cycle_interval).state * 86400); // Convert days to seconds
        
        // Calculate next watering time based on last cycle + interval
        time_t next_cycle_time;
        
        // If we haven't had a cycle yet (last_cycle = 0), use current time as baseline
        if (id(pump_3_last_cycle) == 0) {
          // Calculate next watering as interval from now, at the cron hour
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          // Calculate based on actual last cycle + interval
          next_cycle_time = id(pump_3_last_cycle) + cycle_interval_seconds;
          // Adjust next cycle time to match the cron hour
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        // If the calculated time is in the past, skip to next interval
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400; // Add one day
        }
        
        auto time_diff = next_cycle_time - current_time;
        return time_diff / 3600.0;
      }
      return NAN;
    unit_of_measurement: "hours"

  - platform: template
    name: "Bin 4 Next Cycle Countdown"
    id: pump_4_countdown
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_4_enable).state) {
        return NAN;
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron4 = id(bin_4_cron).state;
      
      if (cron4.length() >= 7) {
        int target_hour = std::stoi(cron4.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_4_cycle_interval).state * 86400); // Convert days to seconds
        
        // Calculate next watering time based on last cycle + interval
        time_t next_cycle_time;
        
        // If we haven't had a cycle yet (last_cycle = 0), use current time as baseline
        if (id(pump_4_last_cycle) == 0) {
          // Calculate next watering as interval from now, at the cron hour
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          // Calculate based on actual last cycle + interval
          next_cycle_time = id(pump_4_last_cycle) + cycle_interval_seconds;
          // Adjust next cycle time to match the cron hour
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        // If the calculated time is in the past, skip to next interval
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400; // Add one day
        }
        
        auto time_diff = next_cycle_time - current_time;
        return time_diff / 3600.0;
      }
      return NAN;
    unit_of_measurement: "hours"

# Text sensors for bin status and cron schedules
text_sensor:
  # Queue status sensor (string values)
  - platform: template
    name: "Queue Status"
    id: queue_status_sensor
    icon: mdi:playlist-play
    lambda: |-
      std::string status = "";
      int count = 0;
      if (id(queue_pending_1)) { status += "Bin 1, "; count++; }
      if (id(queue_pending_2)) { status += "Bin 2, "; count++; }
      if (id(queue_pending_3)) { status += "Bin 3, "; count++; }
      if (id(queue_pending_4)) { status += "Bin 4, "; count++; }
      
      if (count == 0) return {"Empty"};
      if (status.length() > 2) status = status.substr(0, status.length() - 2);
      return {status};
    update_interval: 10s

  - platform: template
    name: "Bin 1 Status"
    id: pump_1_status
    lambda: |-
      return id(pump_1_state);
    update_interval: 1s

  # Human-readable countdown sensors
  - platform: template
    name: "Bin 1 Next Cycle Countdown Text"
    id: pump_1_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_1_enable).state) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron1 = id(bin_1_cron).state;
      
      if (cron1.length() >= 7) {
        int target_hour = std::stoi(cron1.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_1_cycle_interval).state * 86400);
        
        time_t next_cycle_time;
        
        if (id(pump_1_last_cycle) == 0) {
          // Calculate next watering as interval from now, at the cron hour
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          // Calculate based on actual last cycle + interval
          next_cycle_time = id(pump_1_last_cycle) + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        // If the calculated time is in the past, skip to next interval
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400;
        }
        
        auto time_diff = next_cycle_time - current_time;
        int days = time_diff / 86400;
        int hours = (time_diff % 86400) / 3600;
        int minutes = ((time_diff % 86400) % 3600) / 60;
        
        if (days > 0) {
          return {std::to_string(days) + "d " + std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else if (hours > 0) {
          return {std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else {
          return {std::to_string(minutes) + "m"};
        }
      }
      return {"Unknown"};

  - platform: template
    name: "Bin 2 Status"
    id: pump_2_status
    lambda: |-
      return id(pump_2_state);
    update_interval: 1s

  - platform: template
    name: "Bin 2 Next Cycle Countdown Text"
    id: pump_2_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_2_enable).state) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron2 = id(bin_2_cron).state;
      
      if (cron2.length() >= 7) {
        int target_hour = std::stoi(cron2.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_2_cycle_interval).state * 86400);
        
        time_t next_cycle_time;
        
        if (id(pump_2_last_cycle) == 0) {
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          next_cycle_time = id(pump_2_last_cycle) + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400;
        }
        
        auto time_diff = next_cycle_time - current_time;
        int days = time_diff / 86400;
        int hours = (time_diff % 86400) / 3600;
        int minutes = ((time_diff % 86400) % 3600) / 60;
        
        if (days > 0) {
          return {std::to_string(days) + "d " + std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else if (hours > 0) {
          return {std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else {
          return {std::to_string(minutes) + "m"};
        }
      }
      return {"Unknown"};

  - platform: template
    name: "Bin 3 Status"
    id: pump_3_status
    lambda: |-
      return id(pump_3_state);
    update_interval: 1s

  - platform: template
    name: "Bin 3 Next Cycle Countdown Text"
    id: pump_3_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_3_enable).state) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron3 = id(bin_3_cron).state;
      
      if (cron3.length() >= 7) {
        int target_hour = std::stoi(cron3.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_3_cycle_interval).state * 86400);
        
        time_t next_cycle_time;
        
        if (id(pump_3_last_cycle) == 0) {
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          next_cycle_time = id(pump_3_last_cycle) + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400;
        }
        
        auto time_diff = next_cycle_time - current_time;
        int days = time_diff / 86400;
        int hours = (time_diff % 86400) / 3600;
        int minutes = ((time_diff % 86400) % 3600) / 60;
        
        if (days > 0) {
          return {std::to_string(days) + "d " + std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else if (hours > 0) {
          return {std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else {
          return {std::to_string(minutes) + "m"};
        }
      }
      return {"Unknown"};

  - platform: template
    name: "Bin 4 Status"
    id: pump_4_status
    lambda: |-
      return id(pump_4_state);
    update_interval: 1s

  - platform: template
    name: "Bin 4 Next Cycle Countdown Text"
    id: pump_4_countdown_text
    icon: mdi:timer-sand
    update_interval: 60s
    lambda: |-
      if (!id(bin_4_enable).state) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      auto current_time = now.timestamp;
      std::string cron4 = id(bin_4_cron).state;
      
      if (cron4.length() >= 7) {
        int target_hour = std::stoi(cron4.substr(4, 2));
        int cycle_interval_seconds = (int)(id(pump_4_cycle_interval).state * 86400);
        
        time_t next_cycle_time;
        
        if (id(pump_4_last_cycle) == 0) {
          next_cycle_time = current_time + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        } else {
          next_cycle_time = id(pump_4_last_cycle) + cycle_interval_seconds;
          auto next_tm = *localtime(&next_cycle_time);
          next_tm.tm_hour = target_hour;
          next_tm.tm_min = 0;
          next_tm.tm_sec = 0;
          next_cycle_time = mktime(&next_tm);
        }
        
        while (next_cycle_time <= current_time) {
          next_cycle_time += 86400;
        }
        
        auto time_diff = next_cycle_time - current_time;
        int days = time_diff / 86400;
        int hours = (time_diff % 86400) / 3600;
        int minutes = ((time_diff % 86400) % 3600) / 60;
        
        if (days > 0) {
          return {std::to_string(days) + "d " + std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else if (hours > 0) {
          return {std::to_string(hours) + "h " + std::to_string(minutes) + "m"};
        } else {
          return {std::to_string(minutes) + "m"};
        }
      }
      return {"Unknown"};

# Individual cron schedules for each bin
text:
  - platform: template
    name: "Bin 1 Cron Schedule"
    id: bin_1_cron
    optimistic: true
    initial_value: "0 0 9 * * *"  # Daily at 9 AM
    mode: text

  - platform: template
    name: "Bin 2 Cron Schedule"
    id: bin_2_cron
    optimistic: true
    initial_value: "0 0 10 * * *"  # Daily at 10 AM
    mode: text

  - platform: template
    name: "Bin 3 Cron Schedule"
    id: bin_3_cron
    optimistic: true
    initial_value: "0 0 11 * * *"  # Daily at 11 AM
    mode: text

  - platform: template
    name: "Bin 4 Cron Schedule"
    id: bin_4_cron
    optimistic: true
    initial_value: "0 0 12 * * *"  # Daily at 12 PM
    mode: text

# Pump timing settings only (speed is fixed at 65%)
number:
  # Pump 1 Timing Settings
  - platform: template
    name: "Bin 1 Fill Duration Minutes"
    id: pump_1_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 1 Soak Duration Minutes"
    id: pump_1_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 1 Drain Duration Minutes"
    id: pump_1_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 1 Cycle Interval Days"
    id: pump_1_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  # Bin 2 Timing Settings
  - platform: template
    name: "Bin 2 Fill Duration Minutes"
    id: pump_2_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 2 Soak Duration Minutes"
    id: pump_2_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 2 Drain Duration Minutes"
    id: pump_2_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 2 Cycle Interval Days"
    id: pump_2_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  # Bin 3 Timing Settings
  - platform: template
    name: "Bin 3 Fill Duration Minutes"
    id: pump_3_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 3 Soak Duration Minutes"
    id: pump_3_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 3 Drain Duration Minutes"
    id: pump_3_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 3 Cycle Interval Days"
    id: pump_3_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

  # Bin 4 Timing Settings
  - platform: template
    name: "Bin 4 Fill Duration Minutes"
    id: pump_4_fill_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Bin 4 Soak Duration Minutes"
    id: pump_4_soak_duration
    min_value: 1
    max_value: 120
    step: 1
    mode: box
    initial_value: 30
    optimistic: true

  - platform: template
    name: "Bin 4 Drain Duration Minutes"
    id: pump_4_drain_duration
    min_value: 1
    max_value: 60
    step: 1
    mode: box
    initial_value: 10
    optimistic: true

  - platform: template
    name: "Bin 4 Cycle Interval Days"
    id: pump_4_cycle_interval
    min_value: 1
    max_value: 30
    step: 1
    mode: box
    initial_value: 1
    optimistic: true

# Manual cycle buttons
button:
  - platform: template
    name: "Start Bin 1 Cycle"
    id: start_pump_1_cycle
    on_press:
      - lambda: |-
          id(pump_1_last_cycle) = id(homeassistant_time).now().timestamp;
          // Clear pending queue status for manual start
          id(queue_pending_1) = false;
      - script.execute: pump_1_flood_cycle

  - platform: template
    name: "Start Bin 2 Cycle"
    id: start_pump_2_cycle
    on_press:
      - lambda: |-
          id(pump_2_last_cycle) = id(homeassistant_time).now().timestamp;
          // Clear pending queue status for manual start
          id(queue_pending_2) = false;
      - script.execute: pump_2_flood_cycle

  - platform: template
    name: "Start Bin 3 Cycle"
    id: start_pump_3_cycle
    on_press:
      - lambda: |-
          id(pump_3_last_cycle) = id(homeassistant_time).now().timestamp;
          // Clear pending queue status for manual start
          id(queue_pending_3) = false;
      - script.execute: pump_3_flood_cycle

  - platform: template
    name: "Start Bin 4 Cycle"
    id: start_pump_4_cycle
    on_press:
      - lambda: |-
          id(pump_4_last_cycle) = id(homeassistant_time).now().timestamp;
          // Clear pending queue status for manual start
          id(queue_pending_4) = false;
      - script.execute: pump_4_flood_cycle

  - platform: template
    name: "Clear All Pending Cycles"
    id: clear_queue
    icon: mdi:playlist-remove
    on_press:
      - lambda: |-
          // Clear all pending cycles from queue
          id(queue_pending_1) = false;
          id(queue_pending_2) = false;
          id(queue_pending_3) = false;
          id(queue_pending_4) = false;

# Scripts for flood cycles
script:
  - id: pump_1_flood_cycle
    then:
      - globals.set:
          id: pump_1_state
          value: '"Filling"'
      - switch.turn_on: pump_1_reverse
      - switch.turn_on: pump_1
      - delay: !lambda "return (int)(id(pump_1_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_1
      - globals.set:
          id: pump_1_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_1_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_1_state
          value: '"Draining"'
      - switch.turn_off: pump_1_reverse
      - switch.turn_on: pump_1
      - delay: !lambda "return (int)(id(pump_1_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_1
      - switch.turn_off: pump_1_reverse
      - globals.set:
          id: pump_1_state
          value: '"Idle"'

  - id: pump_2_flood_cycle
    then:
      - globals.set:
          id: pump_2_state
          value: '"Filling"'
      - switch.turn_on: pump_2_reverse
      - switch.turn_on: pump_2
      - delay: !lambda "return (int)(id(pump_2_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_2
      - globals.set:
          id: pump_2_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_2_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_2_state
          value: '"Draining"'
      - switch.turn_off: pump_2_reverse
      - switch.turn_on: pump_2
      - delay: !lambda "return (int)(id(pump_2_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_2
      - switch.turn_off: pump_2_reverse
      - globals.set:
          id: pump_2_state
          value: '"Idle"'

  - id: pump_3_flood_cycle
    then:
      - globals.set:
          id: pump_3_state
          value: '"Filling"'
      - switch.turn_on: pump_3_reverse
      - switch.turn_on: pump_3
      - delay: !lambda "return (int)(id(pump_3_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_3
      - globals.set:
          id: pump_3_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_3_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_3_state
          value: '"Draining"'
      - switch.turn_off: pump_3_reverse
      - switch.turn_on: pump_3
      - delay: !lambda "return (int)(id(pump_3_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_3
      - switch.turn_off: pump_3_reverse
      - globals.set:
          id: pump_3_state
          value: '"Idle"'

  - id: pump_4_flood_cycle
    then:
      - globals.set:
          id: pump_4_state
          value: '"Filling"'
      - switch.turn_on: pump_4_reverse
      - switch.turn_on: pump_4
      - delay: !lambda "return (int)(id(pump_4_fill_duration).state * 60 * 1000);"
      - switch.turn_off: pump_4
      - globals.set:
          id: pump_4_state
          value: '"Soaking"'
      - delay: !lambda "return (int)(id(pump_4_soak_duration).state * 60 * 1000);"
      - globals.set:
          id: pump_4_state
          value: '"Draining"'
      - switch.turn_off: pump_4_reverse
      - switch.turn_on: pump_4
      - delay: !lambda "return (int)(id(pump_4_drain_duration).state * 60 * 1000);"
      - switch.turn_off: pump_4
      - switch.turn_off: pump_4_reverse
      - globals.set:
          id: pump_4_state
          value: '"Idle"'
